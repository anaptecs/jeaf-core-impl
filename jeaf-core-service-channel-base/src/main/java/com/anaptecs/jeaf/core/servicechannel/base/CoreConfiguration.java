/**
 * Copyright 2004 - 2019 anaptecs GmbH, Burgstr. 96, 72764 Reutlingen, Germany
 *
 * All rights reserved.
 */
package com.anaptecs.jeaf.core.servicechannel.base;

import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.anaptecs.jeaf.core.annotations.CoreConfig;
import com.anaptecs.jeaf.core.api.Activity;
import com.anaptecs.jeaf.core.api.JEAF;
import com.anaptecs.jeaf.core.servicechannel.api.ComponentFactory;
import com.anaptecs.jeaf.core.servicechannel.api.ContextManager;
import com.anaptecs.jeaf.core.servicechannel.api.LifecycleManager;
import com.anaptecs.jeaf.core.servicechannel.api.ServiceInvocationContextManager;
import com.anaptecs.jeaf.core.servicechannel.api.ServiceProviderFactory;
import com.anaptecs.jeaf.core.servicechannel.api.SessionContextManager;
import com.anaptecs.jeaf.core.servicechannel.api.TransactionContextManager;
import com.anaptecs.jeaf.core.spi.ServiceChannelInterceptor;
import com.anaptecs.jeaf.core.spi.TransactionListener;
import com.anaptecs.jeaf.tools.api.Tools;
import com.anaptecs.jeaf.tools.api.collections.CollectionTools;
import com.anaptecs.jeaf.xfun.annotations.StartupInfoWriterImpl;
import com.anaptecs.jeaf.xfun.api.config.AnnotationBasedConfiguration;
import com.anaptecs.jeaf.xfun.api.config.ConfigurationReader;
import com.anaptecs.jeaf.xfun.api.trace.StartupInfoWriter;
import com.anaptecs.jeaf.xfun.api.trace.Trace;
import com.anaptecs.jeaf.xfun.api.trace.TraceLevel;

/**
 * Class is intended to be used to read JEAF configuration data. This configuration data is located under META-INF/JEAF
 * in the applications classpath and will be generated by JEAF's Maven Plugin during build time.
 * 
 * @author JEAF Development Team
 * @version JEAF Release 1.3.1
 */
@StartupInfoWriterImpl
public class CoreConfiguration extends AnnotationBasedConfiguration<CoreConfig> implements StartupInfoWriter {
  /**
   * Name of the class that contains the default configuration annotation.
   */
  public static final String DEFAULT_CONFIGURATION_CLASS = "com.anaptecs.jeaf.core.defaults.DefaultCoreConfiguration";

  /**
   * Only instance of this class. As configuration data is read via the classpath the is no need to reload it during
   * runtime.
   */
  private static final CoreConfiguration INSTANCE = new CoreConfiguration();

  /**
   * List contains all component factories that are configured as JEAF meta information.
   */
  private List<Class<? extends ComponentFactory>> componentFactoryClasses;

  /**
   * List contains all component factories that are configured as JEAF meta information.
   */
  private List<Class<? extends ServiceProviderFactory>> serviceProviderFactoryClasses;

  /**
   * List contains all activities that are configured as JEAF meta information.
   */
  private List<Class<? extends Activity>> activityImplClasses;

  /**
   * Method returns JEAF configuration
   * 
   * @return {@link CoreConfiguration} Object providing access to JEAF cores configuration.
   */
  public static CoreConfiguration getInstance( ) {
    return INSTANCE;
  }

  /**
   * Initialize object. During initialization the configuration will already be loaded.
   */
  public CoreConfiguration( ) {
    // Do standard configuration lookup as provided by base class.
    super(CoreConfig.JEAF_CORE_CONFIG_RESOURCE_NAME, JEAF.CORE_BASE_PATH, true);

    // In addition to standard configuration from annotation we also load component factories, service providers and
    // activity implementations.
    ConfigurationReader lReader = new ConfigurationReader();
    componentFactoryClasses = lReader.readClassesFromConfigFile(
        com.anaptecs.jeaf.core.annotations.ComponentFactory.COMPONENT_FACTORIES_RESOURCE_NAME, JEAF.CORE_BASE_PATH,
        ComponentFactory.class);
    serviceProviderFactoryClasses = lReader.readClassesFromConfigFile(
        com.anaptecs.jeaf.core.annotations.ServiceProviderFactory.SERVICE_PROVIDER_FACTORIES_RESOURCE_NAME,
        JEAF.CORE_BASE_PATH, ServiceProviderFactory.class);
    activityImplClasses = lReader.readClassesFromConfigFile(
        com.anaptecs.jeaf.core.annotations.JEAFActivityImpl.ACTIVITIES_IMPL_RESOURCE_NAME, JEAF.CORE_BASE_PATH,
        Activity.class);
  }

  @Override
  protected Class<CoreConfig> getAnnotationClass( ) {
    return CoreConfig.class;
  }

  @Override
  protected String getDefaultConfigurationClass( ) {
    // As there is no meaningful default for the JEAF Core configuration we return a generic name of the default class.
    // As JEAF's Core configuration is highly environment specific there will be multiple Maven projects which all
    // provide that class. The desired default configuration can be used by defining a Maven Runtime dependency to the
    // project that has the best fitting default configuration.
    return DEFAULT_CONFIGURATION_CLASS;
  }

  @Override
  public CoreConfig getEmptyConfiguration( ) {
    return new CoreConfig() {

      @Override
      public Class<? extends Annotation> annotationType( ) {
        return CoreConfig.class;
      }

      @Override
      public Class<? extends LifecycleManager> lifecycleManager( ) {
        return null;
      }

      @Override
      public Class<? extends ContextManager> contextManager( ) {
        return null;
      }

      @Override
      public Class<? extends SessionContextManager> sessionContextManager( ) {
        return null;
      }

      @Override
      public Class<? extends TransactionContextManager> transactionContextManager( ) {
        return null;
      }

      @Override
      public Class<? extends ServiceInvocationContextManager> serviceInvocationContextManager( ) {
        return null;
      }

      @SuppressWarnings("unchecked")
      @Override
      public Class<? extends ServiceChannelInterceptor>[] globalInterceptors( ) {
        return new Class[] {};
      }

      @SuppressWarnings("unchecked")
      @Override
      public Class<? extends TransactionListener>[] transactionListeners( ) {
        return new Class[] {};
      }
    };
  }

  @Override
  public List<String> checkCustomConfiguration( CoreConfig pCustomConfiguration ) {
    // As the JEAF Tools configuration just defines classes of interface implementations we just have to ensure that
    // the defined classes are real classes and not just interfaces.
    List<String> lConfigErrors = new ArrayList<>(0);

    // TODO TLS: Implement checks

    // Return result of configuration check.
    return lConfigErrors;
  }

  /**
   * Property defines the life cycle manager implementation that should be used.
   * 
   * {@link LifecycleManager}
   */
  LifecycleManager getLifecycleManager( ) {
    return this.newInstance(customConfig.lifecycleManager(), defaultConfig.lifecycleManager(), exceptionOnError);
  }

  /**
   * Property defines the context manager implementation that should be used.
   * 
   * {@link SessionContextManager}
   */
  ContextManager getContextManager( ) {
    return this.newInstance(customConfig.contextManager(), defaultConfig.contextManager(), exceptionOnError);
  }

  /**
   * Property defines the context manager implementation that should be used.
   * 
   * {@link SessionContextManager}
   */
  SessionContextManager getSessionContextManager( ) {
    return this.newInstance(customConfig.sessionContextManager(), defaultConfig.sessionContextManager(),
        exceptionOnError);
  }

  /**
   * Property defines the context manager implementation that should be used.
   * 
   * {@link SessionContextManager}
   */
  TransactionContextManager getTransactionContextManager( ) {
    return this.newInstance(customConfig.transactionContextManager(), defaultConfig.transactionContextManager(),
        exceptionOnError);
  }

  /**
   * Property defines the context manager implementation that should be used.
   * 
   * {@link SessionContextManager}
   */
  ServiceInvocationContextManager getServiceInvocationContextManager( ) {
    return this.newInstance(customConfig.serviceInvocationContextManager(),
        defaultConfig.serviceInvocationContextManager(), exceptionOnError);
  }

  /**
   * Property defines all global service channel interceptors that should be used. Global interceptors will be called no
   * matter which service is called. In addition JEAF also supports service specific interceptors.
   * 
   * {@link ServiceChannelInterceptor}
   */
  public List<ServiceChannelInterceptor> getGlobalInterceptors( ) {
    // Collect all classes and avoid that we have 2 instances of the same class.
    Set<Class<? extends ServiceChannelInterceptor>> lAllInterceptors = new HashSet<>();
    CollectionTools lCollectionTools = CollectionTools.getCollectionTools();
    lCollectionTools.addAll(lAllInterceptors, customConfig.globalInterceptors());
    lCollectionTools.addAll(lAllInterceptors, defaultConfig.globalInterceptors());

    // Create new instance and return them.
    return this.newInstances(lAllInterceptors, exceptionOnError);
  }

  /**
   * Property defines all transaction listeners that will be notified about transactions.
   * 
   * {@link TransactionListener}
   */
  public List<TransactionListener> getTransactionListeners( ) {
    // Collect all classes and avoid that we have 2 instances of the same class.
    Set<Class<? extends TransactionListener>> lAllListerns = new HashSet<>();
    CollectionTools lCollectionTools = CollectionTools.getCollectionTools();
    lCollectionTools.addAll(lAllListerns, customConfig.transactionListeners());
    lCollectionTools.addAll(lAllListerns, defaultConfig.transactionListeners());

    // Create new instance and return them.
    return this.newInstances(lAllListerns, exceptionOnError);
  }

  /**
   * Method returns all configured component factory classes.
   * 
   * @return {@link List} List with all configured component factory classes. The method never returns null. The
   * returned {@link List} is immutable.
   */
  public List<Class<? extends ComponentFactory>> getComponentFactoryClasses( ) {
    return componentFactoryClasses;
  }

  /**
   * Method returns all configured service provider factory classes.
   * 
   * @return {@link List} List with all configured service provider factory classes. The method never returns null. The
   * returned {@link List} is immutable.
   */
  public List<Class<? extends ServiceProviderFactory>> getServiceProviderFactoryClasses( ) {
    return serviceProviderFactoryClasses;
  }

  /**
   * Method returns all configured activity classes.
   * 
   * @return {@link List} List with all configured activity classes. The method never returns null. The returned
   * {@link List} is immutable.
   */
  public List<Class<? extends Activity>> getActivityImplClasses( ) {
    return activityImplClasses;
  }

  @Override
  public Class<?> getStartupCompletedEventSource( ) {
    return JEAF.class;
  }

  @SuppressWarnings({ "unchecked", "rawtypes" })
  @Override
  public void traceStartupInfo( Trace pTrace, TraceLevel pTraceLevel ) {
    pTrace.writeInitInfo("JEAF Core configuration read from class: " + this.getConfigurationClass().getName(),
        pTraceLevel);
    pTrace.writeInitInfo("JEAF Core uses the following configuration:", pTraceLevel);
    pTrace.writeInitInfo("Lifecycle Manager:                  " + theConfig.lifecycleManager().getName(), pTraceLevel);
    pTrace.writeInitInfo("Context Manager:                    " + theConfig.contextManager().getName(), pTraceLevel);
    pTrace.writeInitInfo("Session Context Manager:            " + theConfig.sessionContextManager().getName(),
        pTraceLevel);
    pTrace.writeInitInfo("Transaction Context Manager:        " + theConfig.transactionContextManager().getName(),
        pTraceLevel);
    pTrace.writeInitInfo("Service Invocation Context Manager: " + theConfig.serviceInvocationContextManager().getName(),
        pTraceLevel);
    pTrace.writeInitInfo("Global Interceptors:                "
        + Tools.getStringTools().getClassNamesAsString(theConfig.globalInterceptors(), "none"), pTraceLevel);
    pTrace.writeInitInfo("Transaction Listeners:              "
        + Tools.getStringTools().getClassNamesAsString(theConfig.transactionListeners(), "none"), pTraceLevel);
    pTrace.writeInitInfo("Component Factories:                "
        + Tools.getStringTools().getClassNamesAsString((List) componentFactoryClasses, "none"), pTraceLevel);
    pTrace.writeInitInfo("Service Provider Factories:         "
        + Tools.getStringTools().getClassNamesAsString((List) serviceProviderFactoryClasses, "none"), pTraceLevel);
    pTrace.writeInitInfo("Activity Implementations:           "
        + Tools.getStringTools().getClassNamesAsString((List) activityImplClasses, "none"), pTraceLevel);
  }

}
