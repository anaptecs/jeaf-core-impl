/**
 * Copyright 2004 - 2019 anaptecs GmbH, Burgstr. 96, 72764 Reutlingen, Germany
 *
 * All rights reserved.
 */
package com.anaptecs.jeaf.core.servicechannel.base;

import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.anaptecs.jeaf.core.annotations.SecurityConfig;
import com.anaptecs.jeaf.core.api.JEAF;
import com.anaptecs.jeaf.core.api.Service;
import com.anaptecs.jeaf.core.spi.ServiceChannelInterceptor;
import com.anaptecs.jeaf.tools.api.collections.CollectionTools;
import com.anaptecs.jeaf.xfun.api.config.AnnotationBasedConfiguration;
import com.anaptecs.jeaf.xfun.api.principal.PrincipalProvider;

/**
 * Class is intended to be used to read JEAF configuration data. This configuration data is located under META-INF/JEAF
 * in the applications classpath and will be generated by JEAF's Maven Plugin during build time.
 * 
 * @author JEAF Development Team
 * @version JEAF Release 1.3.1
 */
public class SecurityConfiguration extends AnnotationBasedConfiguration<SecurityConfig> {
  /**
   * Name of the class that contains the default configuration annotation.
   */
  public static final String DEFAULT_CONFIGURATION_CLASS = "com.anaptecs.jeaf.core.defaults.DefaultCoreConfiguration";

  /**
   * Only instance of this class. As configuration data is read via the classpath the is no need to reload it during
   * runtime.
   */
  private static final SecurityConfiguration INSTANCE = new SecurityConfiguration();

  /**
   * Method returns JEAF configuration
   * 
   * @return {@link SecurityConfiguration} Object providing access to JEAF cores configuration.
   */
  public static SecurityConfiguration getInstance( ) {
    return INSTANCE;
  }

  /**
   * Initialize object. During initialization the configuration will already be loaded.
   */
  private SecurityConfiguration( ) {
    // Do standard configuration lookup as provided by base class.
    super(SecurityConfig.SECURITY_CONFIG_RESOURCE_NAME, JEAF.CORE_BASE_PATH, true);
  }

  @Override
  protected Class<SecurityConfig> getAnnotationClass( ) {
    return SecurityConfig.class;
  }

  @Override
  protected String getDefaultConfigurationClass( ) {
    // As there is no meaningful default for the JEAF Core configuration we return a generic name of the default class.
    // As JEAF's Core configuration is highly environment specific there will be multiple Maven projects which all
    // provide that class. The desired default configuration can be used by defining a Maven Runtime dependency to the
    // project that has the best fitting default configuration.
    return DEFAULT_CONFIGURATION_CLASS;
  }

  @Override
  public SecurityConfig getEmptyConfiguration( ) {
    return new SecurityConfig() {

      @Override
      public Class<? extends Annotation> annotationType( ) {
        return SecurityConfig.class;
      }

      @Override
      public Class<? extends Service>[] exportedServices( ) {
        return null;
      }

      @Override
      public boolean enableSecurity( ) {
        return SecurityConfig.JEAF_SECURITY_DEFAULT;
      }

      @Override
      public Class<? extends ServiceChannelInterceptor> securityInterceptor( ) {
        return null;
      }

      @Override
      public boolean restrictAccessToExportedServices( ) {
        return SecurityConfig.LIMIT_ACCESS_TO_PUBLIC_SERVICES_DEFAULT;
      }
    };
  }

  @Override
  public List<String> checkCustomConfiguration( SecurityConfig pCustomConfiguration ) {
    // As the JEAF Tools configuration just defines classes of interface implementations we just have to ensure that
    // the defined classes are real classes and not just interfaces.
    List<String> lConfigErrors = new ArrayList<>(0);

    // TODO TLS: Implement checks

    // Return result of configuration check.
    return lConfigErrors;
  }

  /**
   * Property defines if only service can be called from outside the JVM that are explicitly exported through this
   * configuration. By default services have to be exported to be accessible for external calls
   * {@link #exportedServices()}
   */
  public boolean restrictAccessToExportedServices( ) {
    return theConfig.restrictAccessToExportedServices();
  }

  /**
   * Property defines which services are accessible for external calls. This configuration has only impact if
   * <code>restrictAccessToExportedServices</code> is set to true.
   * 
   * {@link PrincipalProvider}
   */
  public List<Class<? extends Service>> getExportedServices( ) {
    // Collect all classes and avoid that we have 2 instances of the same class.
    Set<Class<? extends Service>> lAllServices = new HashSet<>();
    CollectionTools lCollectionTools = CollectionTools.getCollectionTools();
    lCollectionTools.addAll(lAllServices, customConfig.exportedServices());
    lCollectionTools.addAll(lAllServices, defaultConfig.exportedServices());

    return new ArrayList<>(lAllServices);
  }

  /**
   * Property defines if JEAF security should be used or not. By default it is enabled.
   * 
   * {@link PrincipalProvider}
   */
  public boolean isJEAFSecurityEnabled( ) {
    return theConfig.enableSecurity();
  }

  /**
   * Property the implementation that should be used to ensure JEAF security.
   * 
   * {@link ServiceChannelInterceptor}
   */
  public ServiceChannelInterceptor getSecurityInterceptor( ) {
    return this.newInstance(customConfig.securityInterceptor(), defaultConfig.securityInterceptor(), exceptionOnError);
  }
}
