/**
 * Copyright 2004 - 2019 anaptecs GmbH, Burgstr. 96, 72764 Reutlingen, Germany
 *
 * All rights reserved.
 */
package com.anaptecs.jeaf.core.servicechannel.base;

import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.anaptecs.jeaf.core.annotations.SchedulingConfig;
import com.anaptecs.jeaf.core.api.JEAF;
import com.anaptecs.jeaf.core.servicechannel.api.SchedulerCredentialProvider;
import com.anaptecs.jeaf.core.servicechannel.api.Trigger;
import com.anaptecs.jeaf.tools.api.collections.CollectionTools;
import com.anaptecs.jeaf.xfun.api.config.AnnotationBasedConfiguration;
import com.anaptecs.jeaf.xfun.api.principal.PrincipalProvider;

/**
 * Class is intended to be used to read JEAF configuration data. This configuration data is located under META-INF/JEAF
 * in the applications classpath and will be generated by JEAF's Maven Plugin during build time.
 * 
 * @author JEAF Development Team
 * @version JEAF Release 1.3.1
 */
public class SchedulingConfiguration extends AnnotationBasedConfiguration<SchedulingConfig> {
  /**
   * Name of the class that contains the default configuration annotation.
   */
  public static final String DEFAULT_CONFIGURATION_CLASS = "com.anaptecs.jeaf.core.defaults.DefaultCoreConfiguration";

  /**
   * Only instance of this class. As configuration data is read via the classpath the is no need to reload it during
   * runtime.
   */
  private static final SchedulingConfiguration INSTANCE = new SchedulingConfiguration();

  /**
   * Method returns JEAF configuration
   * 
   * @return {@link SchedulingConfiguration} Object providing access to JEAF cores configuration.
   */
  public static SchedulingConfiguration getInstance( ) {
    return INSTANCE;
  }

  /**
   * Initialize object. During initialization the configuration will already be loaded.
   */
  private SchedulingConfiguration( ) {
    // Do standard configuration lookup as provided by base class.
    super(SchedulingConfig.SCHEDULING_CONFIG_RESOURCE_NAME, JEAF.CORE_BASE_PATH, true);
  }

  @Override
  protected Class<SchedulingConfig> getAnnotationClass( ) {
    return SchedulingConfig.class;
  }

  @Override
  protected String getDefaultConfigurationClass( ) {
    // As there is no meaningful default for the JEAF Core configuration we return a generic name of the default class.
    // As JEAF's Core configuration is highly environment specific there will be multiple Maven projects which all
    // provide that class. The desired default configuration can be used by defining a Maven Runtime dependency to the
    // project that has the best fitting default configuration.
    return DEFAULT_CONFIGURATION_CLASS;
  }

  @Override
  public SchedulingConfig getEmptyConfiguration( ) {
    return new SchedulingConfig() {

      @Override
      public Class<? extends Annotation> annotationType( ) {
        return SchedulingConfig.class;
      }

      @Override
      public boolean enableScheduling( ) {
        return SchedulingConfig.JEAF_SCHEDULING_DEFAULT;
      }

      @Override
      public int triggerInterval( ) {
        return SchedulingConfig.TRIGGER_INTERVAL_DEFAULT;
      }

      @Override
      public Class<? extends SchedulerCredentialProvider> schedulerCredentialProvider( ) {
        return null;
      }

      @SuppressWarnings("unchecked")
      @Override
      public Class<? extends Trigger>[] triggers( ) {
        return new Class[] {};
      }
    };
  }

  @Override
  public List<String> checkCustomConfiguration( SchedulingConfig pCustomConfiguration ) {
    // As the JEAF Tools configuration just defines classes of interface implementations we just have to ensure that
    // the defined classes are real classes and not just interfaces.
    List<String> lConfigErrors = new ArrayList<>(0);

    // TODO TLS: Implement checks

    // Return result of configuration check.
    return lConfigErrors;
  }

  /**
   * Property defines if JEAF's scheduling mechanism is enabled or not.
   */
  public boolean isJEAFSchedulingEnabled( ) {
    return theConfig.enableScheduling();
  }

  /**
   * Property defines the principal provider implementation that should be used.
   * 
   * {@link PrincipalProvider}
   */
  public int getTriggerInterval( ) {
    return theConfig.triggerInterval();
  }

  /**
   * Property defines the class that provides the credentials of the user under which the triggers will be notified.
   * Depending on the concrete environment thet can be multiple ways how these credentials are passed to JEAF.
   * 
   * {@link SchedulerCredentialProvider}
   */
  SchedulerCredentialProvider getSchedulerCredentialProvider( ) {
    return this.newInstance(customConfig.schedulerCredentialProvider(), defaultConfig.schedulerCredentialProvider(),
        exceptionOnError);
  }

  /**
   * Property defines all triggers that will be notified whenever a cycle is completed. For further details about
   * scheduling please refer to {@link Trigger}.
   */
  List<Trigger> getTriggers( ) {
    // Collect all classes and avoid that we have 2 instances of the same class.
    Set<Class<? extends Trigger>> lAllTriggers = new HashSet<>();
    CollectionTools lCollectionTools = CollectionTools.getCollectionTools();
    lCollectionTools.addAll(lAllTriggers, customConfig.triggers());
    lCollectionTools.addAll(lAllTriggers, defaultConfig.triggers());

    // Create new instance and return them.
    return this.newInstances(lAllTriggers, exceptionOnError);
  }
}
